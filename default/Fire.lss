
Fire.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000042  00800100  00000766  000007fa  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00000766  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          0000003b  00800142  00800142  0000083c  2**0
                  ALLOC
  3 .stab         000006cc  00000000  00000000  0000083c  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00000085  00000000  00000000  00000f08  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 00000040  00000000  00000000  00000f8d  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_pubnames 00000161  00000000  00000000  00000fcd  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   00000ba1  00000000  00000000  0000112e  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 0000040a  00000000  00000000  00001ccf  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   000009ed  00000000  00000000  000020d9  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  00000190  00000000  00000000  00002ac8  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    000002f0  00000000  00000000  00002c58  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    0000047b  00000000  00000000  00002f48  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_pubtypes 00000070  00000000  00000000  000033c3  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 46 00 	jmp	0x8c	; 0x8c <__ctors_end>
   4:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
   8:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
   c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  10:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  14:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  18:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  1c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  20:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  24:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  28:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  2c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  30:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  34:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  38:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  3c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  40:	0c 94 ad 01 	jmp	0x35a	; 0x35a <__vector_16>
  44:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  48:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  4c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  50:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  54:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  58:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  5c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  60:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  64:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  68:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  6c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  70:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  74:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  78:	0c 94 c1 00 	jmp	0x182	; 0x182 <__vector_30>
  7c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  80:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  84:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  88:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>

0000008c <__ctors_end>:
  8c:	11 24       	eor	r1, r1
  8e:	1f be       	out	0x3f, r1	; 63
  90:	cf ef       	ldi	r28, 0xFF	; 255
  92:	d0 e1       	ldi	r29, 0x10	; 16
  94:	de bf       	out	0x3e, r29	; 62
  96:	cd bf       	out	0x3d, r28	; 61

00000098 <__do_copy_data>:
  98:	11 e0       	ldi	r17, 0x01	; 1
  9a:	a0 e0       	ldi	r26, 0x00	; 0
  9c:	b1 e0       	ldi	r27, 0x01	; 1
  9e:	e6 e6       	ldi	r30, 0x66	; 102
  a0:	f7 e0       	ldi	r31, 0x07	; 7
  a2:	00 e0       	ldi	r16, 0x00	; 0
  a4:	0b bf       	out	0x3b, r16	; 59
  a6:	02 c0       	rjmp	.+4      	; 0xac <__do_copy_data+0x14>
  a8:	07 90       	elpm	r0, Z+
  aa:	0d 92       	st	X+, r0
  ac:	a2 34       	cpi	r26, 0x42	; 66
  ae:	b1 07       	cpc	r27, r17
  b0:	d9 f7       	brne	.-10     	; 0xa8 <__do_copy_data+0x10>

000000b2 <__do_clear_bss>:
  b2:	11 e0       	ldi	r17, 0x01	; 1
  b4:	a2 e4       	ldi	r26, 0x42	; 66
  b6:	b1 e0       	ldi	r27, 0x01	; 1
  b8:	01 c0       	rjmp	.+2      	; 0xbc <.do_clear_bss_start>

000000ba <.do_clear_bss_loop>:
  ba:	1d 92       	st	X+, r1

000000bc <.do_clear_bss_start>:
  bc:	ad 37       	cpi	r26, 0x7D	; 125
  be:	b1 07       	cpc	r27, r17
  c0:	e1 f7       	brne	.-8      	; 0xba <.do_clear_bss_loop>
  c2:	0e 94 84 00 	call	0x108	; 0x108 <main>
  c6:	0c 94 b1 03 	jmp	0x762	; 0x762 <_exit>

000000ca <__bad_interrupt>:
  ca:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000ce <DC_FAN_Run_Fwd.1397>:
       //////////////////////////////////////////////////////////////////

void DC_FAN_Run_Fwd( short duty )   // FAN 정회전 함수 
{

    if( duty > Vmax )     duty = Vmax ;
  ce:	20 91 57 01 	lds	r18, 0x0157
  d2:	30 91 58 01 	lds	r19, 0x0158
  d6:	28 17       	cp	r18, r24
  d8:	39 07       	cpc	r19, r25
  da:	24 f4       	brge	.+8      	; 0xe4 <DC_FAN_Run_Fwd.1397+0x16>
  dc:	80 91 57 01 	lds	r24, 0x0157
  e0:	90 91 58 01 	lds	r25, 0x0158

    PORTA &= ~0x01;     //  FAN구동신호 - 단자 : 0 V 인가( PA0 = 0 );  
  e4:	d8 98       	cbi	0x1b, 0	; 27
	OCR1A = duty;       //  FAN구동신호 + 단자 : OC1A(PB5) PWM duty 설정 
  e6:	9b bd       	out	0x2b, r25	; 43
  e8:	8a bd       	out	0x2a, r24	; 42


}
  ea:	08 95       	ret

000000ec <init_serial>:



void init_serial(void)
{
    UCSR1A=0x00;                    //초기화
  ec:	10 92 9b 00 	sts	0x009B, r1
    UCSR1B = 0x18  ;                //송수신허용,  송수신 인터럽트 금지
  f0:	88 e1       	ldi	r24, 0x18	; 24
  f2:	80 93 9a 00 	sts	0x009A, r24
    UCSR1C=0x06;                    //데이터 전송비트 수 8비트로 설정.
  f6:	86 e0       	ldi	r24, 0x06	; 6
  f8:	80 93 9d 00 	sts	0x009D, r24
    
    UBRR1H=0x00;
  fc:	10 92 98 00 	sts	0x0098, r1
    UBRR1L=103;                     //Baud Rate 9600 
 100:	87 e6       	ldi	r24, 0x67	; 103
 102:	80 93 99 00 	sts	0x0099, r24
}
 106:	08 95       	ret

00000108 <main>:
int main() 
{   
	
	unsigned char cmd_data = 0xFF  ;  

	DDRB |= 0x10;     // LED (PB4 : 출력설정 )
 108:	bc 9a       	sbi	0x17, 4	; 23
	PORTB |= 0x10;    // PB4  : High ( LED OFF)  
 10a:	c4 9a       	sbi	0x18, 4	; 24

	
	DDRB |= 0x08;     // LED (PB3 : 출력설정 )
 10c:	bb 9a       	sbi	0x17, 3	; 23
	PORTB |= 0x08;    // PB3  : High ( LED OFF)  
 10e:	c3 9a       	sbi	0x18, 3	; 24

	DDRB |= 0x04 ;    // 능동버저(Buzzer) ( PB2 : 출력 )
 110:	ba 9a       	sbi	0x17, 2	; 23
	PORTB |= 0x04 ;   // PB2 : Low (버저 OFF)
 112:	c2 9a       	sbi	0x18, 2	; 24


	DDRB |= 0x20;   // FAN구동신호 + 단자:  PWM 포트( pin: OC1A(PB5) )   --> 출력 설정 
 114:	bd 9a       	sbi	0x17, 5	; 23
	DDRA |= 0x01;   // FAN구동신호 - 단자 : 범용 입/출력포트(pin : PA0 ) --> 출력 설정 
 116:	d0 9a       	sbi	0x1a, 0	; 26

	LcdInit();               // LCD 초기화
 118:	0e 94 07 03 	call	0x60e	; 0x60e <LcdInit>
	init_serial() ;          // Serial Port (USART1) 초기화
 11c:	0e 94 76 00 	call	0xec	; 0xec <init_serial>
	UCSR1B |=  0x80  ;       // UART1 송신(RX) 완료 인터럽트 허용
 120:	80 91 9a 00 	lds	r24, 0x009A
 124:	80 68       	ori	r24, 0x80	; 128
 126:	80 93 9a 00 	sts	0x009A, r24
	sei() ; 
 12a:	78 94       	sei

////// FAN 구동신호 ( pin: OC1A(PB5) ),   Timer1, PWM signal (period= 200 usec )

	TCCR1A = 0x82;    // OC1A(PB5)) :  PWM 포트 설정,   Fast PWM ( mode 14 )
 12c:	82 e8       	ldi	r24, 0x82	; 130
 12e:	8f bd       	out	0x2f, r24	; 47
	TCCR1B = 0x1b;    // 64 분주 타이머 1 시작 (내부클럭 주기 =  64/(16*10^6) = 4 usec ),  Fast PWM ( mode 14 ) 
 130:	8b e1       	ldi	r24, 0x1B	; 27
 132:	8e bd       	out	0x2e, r24	; 46
	ICR1 = 50;        // PWM 주기 = 50 * 4 usec = 200 usec (  PWM 주파수 = 1/200usec = 5 kHz )
 134:	82 e3       	ldi	r24, 0x32	; 50
 136:	90 e0       	ldi	r25, 0x00	; 0
 138:	97 bd       	out	0x27, r25	; 39
 13a:	86 bd       	out	0x26, r24	; 38

    Vmax = ICR1; 
 13c:	86 b5       	in	r24, 0x26	; 38
 13e:	97 b5       	in	r25, 0x27	; 39
 140:	90 93 58 01 	sts	0x0158, r25
 144:	80 93 57 01 	sts	0x0157, r24

	OCR1A = duty;      //  OC1A(PB5) PWM duty = 0 설정 : 모터 정지
 148:	80 91 42 01 	lds	r24, 0x0142
 14c:	90 91 43 01 	lds	r25, 0x0143
 150:	9b bd       	out	0x2b, r25	; 43
 152:	8a bd       	out	0x2a, r24	; 42


 
/*****   AD Converter **********/

	ADMUX &= ~0xE0;    //  ADC 기준전압 = AREF ,   ADC 결과 오른쪽정렬 
 154:	87 b1       	in	r24, 0x07	; 7
 156:	8f 71       	andi	r24, 0x1F	; 31
 158:	87 b9       	out	0x07, r24	; 7
	ADCSRA |= 0x87;     // ADC enable, Prescaler = 128
 15a:	86 b1       	in	r24, 0x06	; 6
 15c:	87 68       	ori	r24, 0x87	; 135
 15e:	86 b9       	out	0x06, r24	; 6

/**** Timer0 Overflow Interrupt  ******/
/**************************************/
	TCCR0 = 0x00; 
 160:	13 be       	out	0x33, r1	; 51
    TCNT0 = 256 - 156;       //  내부클럭주기 = 1024/ (16x10^6) = 64 usec,  
 162:	84 e6       	ldi	r24, 0x64	; 100
 164:	82 bf       	out	0x32, r24	; 50
                             //  오버플로인터럽트 주기 = 10msec
                             //  156 = 10msec/ 64use

	TIMSK = 0x01;  // Timer0 overflow interrupt enable 
 166:	81 e0       	ldi	r24, 0x01	; 1
 168:	87 bf       	out	0x37, r24	; 55
	sei();         // Global Interrupt Enable 
 16a:	78 94       	sei


	TCCR0 |= 0x07; // Clock Prescaler N=1024 (Timer 0 Start)
 16c:	83 b7       	in	r24, 0x33	; 51
 16e:	87 60       	ori	r24, 0x07	; 7
 170:	83 bf       	out	0x33, r24	; 51
 172:	ff cf       	rjmp	.-2      	; 0x172 <main+0x6a>

00000174 <SerialPutChar>:
// 한 문자를 송신한다.
//======================================

void SerialPutChar(char ch)
{
	while(!(UCSR1A & (1<<UDRE)));			// 버퍼가 빌 때를 기다림
 174:	90 91 9b 00 	lds	r25, 0x009B
 178:	95 ff       	sbrs	r25, 5
 17a:	fc cf       	rjmp	.-8      	; 0x174 <SerialPutChar>
  	UDR1 = ch;								// 버퍼에 문자를 쓴다
 17c:	80 93 9c 00 	sts	0x009C, r24
}
 180:	08 95       	ret

00000182 <__vector_30>:


// UART1 수신 인터럽트 서비스 프로그렘 

ISR(  USART1_RX_vect )
{
 182:	1f 92       	push	r1
 184:	0f 92       	push	r0
 186:	0f b6       	in	r0, 0x3f	; 63
 188:	0f 92       	push	r0
 18a:	0b b6       	in	r0, 0x3b	; 59
 18c:	0f 92       	push	r0
 18e:	11 24       	eor	r1, r1
 190:	2f 93       	push	r18
 192:	3f 93       	push	r19
 194:	4f 93       	push	r20
 196:	5f 93       	push	r21
 198:	6f 93       	push	r22
 19a:	7f 93       	push	r23
 19c:	8f 93       	push	r24
 19e:	9f 93       	push	r25
 1a0:	af 93       	push	r26
 1a2:	bf 93       	push	r27
 1a4:	ef 93       	push	r30
 1a6:	ff 93       	push	r31

    static unsigned char r_cnt = 0 ;

    rdata = UDR1; 
 1a8:	80 91 9c 00 	lds	r24, 0x009C
 1ac:	80 93 59 01 	sts	0x0159, r24

    if( rdata != '.' )                      // 수신된 데이터가 마지막 문자를 나타내는 데이터(마침표)가 아니면
 1b0:	80 91 59 01 	lds	r24, 0x0159
 1b4:	8e 32       	cpi	r24, 0x2E	; 46
 1b6:	99 f0       	breq	.+38     	; 0x1de <__vector_30+0x5c>
    {
        SerialPutChar( rdata);               // Echo  수신된 데이터를 바로 송신하여 수신된 데이터가 정확한지 확인 
 1b8:	80 91 59 01 	lds	r24, 0x0159
 1bc:	0e 94 ba 00 	call	0x174	; 0x174 <SerialPutChar>
   	    recv_data[r_cnt] = rdata;        //  수신된 문자 저장 
 1c0:	80 91 7a 01 	lds	r24, 0x017A
 1c4:	e8 2f       	mov	r30, r24
 1c6:	f0 e0       	ldi	r31, 0x00	; 0
 1c8:	90 91 59 01 	lds	r25, 0x0159
 1cc:	e6 5a       	subi	r30, 0xA6	; 166
 1ce:	fe 4f       	sbci	r31, 0xFE	; 254
 1d0:	90 83       	st	Z, r25
	    r_cnt++;                         //  수신 문자 갯수 증가 
 1d2:	8f 5f       	subi	r24, 0xFF	; 255
 1d4:	80 93 7a 01 	sts	0x017A, r24

		new_recv_flag = 0;
 1d8:	10 92 78 01 	sts	0x0178, r1
 1dc:	10 c0       	rjmp	.+32     	; 0x1fe <__vector_30+0x7c>

    }
    else if(  rdata == '.' )                // 수신된데이터가 마지막 문자를 나타내는 데이터(마침표) 이면
 1de:	80 91 59 01 	lds	r24, 0x0159
 1e2:	8e 32       	cpi	r24, 0x2E	; 46
 1e4:	61 f4       	brne	.+24     	; 0x1fe <__vector_30+0x7c>
    {
        SerialPutChar('\n');                // 휴대폰으로 데이터 전송시 Line Feed('\n')를 항상 끝에 전송해야함 
 1e6:	8a e0       	ldi	r24, 0x0A	; 10
 1e8:	0e 94 ba 00 	call	0x174	; 0x174 <SerialPutChar>
        recv_cnt = r_cnt ;                  // 수신된 데이터 바이트수 저장
 1ec:	80 91 7a 01 	lds	r24, 0x017A
 1f0:	80 93 79 01 	sts	0x0179, r24
        r_cnt = 0;  
 1f4:	10 92 7a 01 	sts	0x017A, r1
        
		new_recv_flag = 1;
 1f8:	81 e0       	ldi	r24, 0x01	; 1
 1fa:	80 93 78 01 	sts	0x0178, r24

    }


}
 1fe:	ff 91       	pop	r31
 200:	ef 91       	pop	r30
 202:	bf 91       	pop	r27
 204:	af 91       	pop	r26
 206:	9f 91       	pop	r25
 208:	8f 91       	pop	r24
 20a:	7f 91       	pop	r23
 20c:	6f 91       	pop	r22
 20e:	5f 91       	pop	r21
 210:	4f 91       	pop	r20
 212:	3f 91       	pop	r19
 214:	2f 91       	pop	r18
 216:	0f 90       	pop	r0
 218:	0b be       	out	0x3b, r0	; 59
 21a:	0f 90       	pop	r0
 21c:	0f be       	out	0x3f, r0	; 63
 21e:	0f 90       	pop	r0
 220:	1f 90       	pop	r1
 222:	18 95       	reti

00000224 <SerialPutString>:
// 문자열을 송신한다.
// 입력   : str - 송신한 문자열을 저장할 버퍼의 주소
//=============================================

 void SerialPutString(char *str)
 {
 224:	ef 92       	push	r14
 226:	ff 92       	push	r15
 228:	cf 93       	push	r28
 22a:	df 93       	push	r29
 22c:	e8 2e       	mov	r14, r24
 22e:	e7 01       	movw	r28, r14
 230:	7e 01       	movw	r14, r28
 232:	f9 2e       	mov	r15, r25
 234:	e7 01       	movw	r28, r14

    while(*str != '\0')
 236:	02 c0       	rjmp	.+4      	; 0x23c <SerialPutString+0x18>
    {

        SerialPutChar(*str++);
 238:	0e 94 ba 00 	call	0x174	; 0x174 <SerialPutChar>
//=============================================

 void SerialPutString(char *str)
 {

    while(*str != '\0')
 23c:	89 91       	ld	r24, Y+
 23e:	88 23       	and	r24, r24
 240:	d9 f7       	brne	.-10     	; 0x238 <SerialPutString+0x14>
    {

        SerialPutChar(*str++);
    }
}
 242:	df 91       	pop	r29
 244:	cf 91       	pop	r28
 246:	ff 90       	pop	r15
 248:	ef 90       	pop	r14
 24a:	08 95       	ret

0000024c <bluetooth>:

}

void bluetooth () // 블루투스 경고 함수 호출
{
	if(Flag == 1)
 24c:	80 91 7b 01 	lds	r24, 0x017B
 250:	90 91 7c 01 	lds	r25, 0x017C
 254:	81 30       	cpi	r24, 0x01	; 1
 256:	91 05       	cpc	r25, r1
 258:	41 f4       	brne	.+16     	; 0x26a <bluetooth+0x1e>
	{
	SerialPutString( "Warning! Fire detected!\n" ); 
 25a:	80 e0       	ldi	r24, 0x00	; 0
 25c:	91 e0       	ldi	r25, 0x01	; 1
 25e:	0e 94 12 01 	call	0x224	; 0x224 <SerialPutString>
	Flag = 0;
 262:	10 92 7c 01 	sts	0x017C, r1
 266:	10 92 7b 01 	sts	0x017B, r1
 26a:	08 95       	ret

0000026c <HexToDec>:

}


void HexToDec( unsigned short num, unsigned short radix) 
{
 26c:	fb 01       	movw	r30, r22
	int j ;

	for(j=0; j<5 ; j++) cnumber[j] = 0 ;
 26e:	10 92 44 01 	sts	0x0144, r1
 272:	10 92 45 01 	sts	0x0145, r1
 276:	10 92 46 01 	sts	0x0146, r1
 27a:	10 92 47 01 	sts	0x0147, r1
 27e:	10 92 48 01 	sts	0x0148, r1
 282:	20 e0       	ldi	r18, 0x00	; 0
 284:	30 e0       	ldi	r19, 0x00	; 0

	j=0;
	do
	{
		cnumber[j++] = num % radix ; 
 286:	bf 01       	movw	r22, r30
 288:	0e 94 9d 03 	call	0x73a	; 0x73a <__udivmodhi4>
 28c:	d9 01       	movw	r26, r18
 28e:	ac 5b       	subi	r26, 0xBC	; 188
 290:	be 4f       	sbci	r27, 0xFE	; 254
 292:	8c 93       	st	X, r24
 294:	2f 5f       	subi	r18, 0xFF	; 255
 296:	3f 4f       	sbci	r19, 0xFF	; 255
		num /= radix; 
 298:	cb 01       	movw	r24, r22

	} while(num);
 29a:	00 97       	sbiw	r24, 0x00	; 0
 29c:	a1 f7       	brne	.-24     	; 0x286 <HexToDec+0x1a>

} 
 29e:	08 95       	ret

000002a0 <NumToAsc>:

char NumToAsc( unsigned char Num )
{
	if( Num <10 ) Num += 0x30; 
 2a0:	8a 30       	cpi	r24, 0x0A	; 10
 2a2:	10 f4       	brcc	.+4      	; 0x2a8 <NumToAsc+0x8>
 2a4:	80 5d       	subi	r24, 0xD0	; 208
 2a6:	08 95       	ret
	else          Num += 0x37; 
 2a8:	89 5c       	subi	r24, 0xC9	; 201

	return Num ;
}
 2aa:	08 95       	ret

000002ac <Display_TMP_LCD>:

}


void Display_TMP_LCD( unsigned int tp  )       // 온도를 10진수 형태로 LCD 에 디스플레이 
{
 2ac:	cf 93       	push	r28
 2ae:	df 93       	push	r29

	HexToDec( tp, 10); //10진수로 변환 
 2b0:	6a e0       	ldi	r22, 0x0A	; 10
 2b2:	70 e0       	ldi	r23, 0x00	; 0
 2b4:	0e 94 36 01 	call	0x26c	; 0x26c <HexToDec>

 
    LcdPutchar(NumToAsc(cnumber[2]) );   // 10자리 디스플레이
 2b8:	c6 e4       	ldi	r28, 0x46	; 70
 2ba:	d1 e0       	ldi	r29, 0x01	; 1
 2bc:	80 91 46 01 	lds	r24, 0x0146
 2c0:	0e 94 50 01 	call	0x2a0	; 0x2a0 <NumToAsc>
 2c4:	0e 94 34 03 	call	0x668	; 0x668 <LcdPutchar>
	
    LcdPutchar(NumToAsc(cnumber[1]));    // 1자리 디스플레이 
 2c8:	fe 01       	movw	r30, r28
 2ca:	31 97       	sbiw	r30, 0x01	; 1
 2cc:	80 81       	ld	r24, Z
 2ce:	0e 94 50 01 	call	0x2a0	; 0x2a0 <NumToAsc>
 2d2:	0e 94 34 03 	call	0x668	; 0x668 <LcdPutchar>

    LcdPuts( ".");                       // 소숫점(.) 디스플레이 
 2d6:	89 e1       	ldi	r24, 0x19	; 25
 2d8:	91 e0       	ldi	r25, 0x01	; 1
 2da:	0e 94 4d 03 	call	0x69a	; 0x69a <LcdPuts>

    LcdPutchar(NumToAsc(cnumber[0]));    // 0.1 자리 디스플레이 
 2de:	22 97       	sbiw	r28, 0x02	; 2
 2e0:	88 81       	ld	r24, Y
 2e2:	0e 94 50 01 	call	0x2a0	; 0x2a0 <NumToAsc>
 2e6:	0e 94 34 03 	call	0x668	; 0x668 <LcdPutchar>

 

}
 2ea:	df 91       	pop	r29
 2ec:	cf 91       	pop	r28
 2ee:	08 95       	ret

000002f0 <Display_Number_LCD>:




void Display_Number_LCD( unsigned int num, unsigned char digit )       // 부호없는 정수형 변수를 10진수 형태로 LCD 에 디스플레이 
{
 2f0:	1f 93       	push	r17
 2f2:	16 2f       	mov	r17, r22

	HexToDec( num, 10); //10진수로 변환 
 2f4:	6a e0       	ldi	r22, 0x0A	; 10
 2f6:	70 e0       	ldi	r23, 0x00	; 0
 2f8:	0e 94 36 01 	call	0x26c	; 0x26c <HexToDec>

	if( digit == 0 )     digit = 1 ;
 2fc:	11 23       	and	r17, r17
 2fe:	29 f1       	breq	.+74     	; 0x34a <Display_Number_LCD+0x5a>
	if( digit > 5 )      digit = 5 ;
 300:	16 30       	cpi	r17, 0x06	; 6
 302:	10 f4       	brcc	.+4      	; 0x308 <Display_Number_LCD+0x18>
 
    if( digit >= 5 )     LcdPutchar( NumToAsc(cnumber[4]) );  // 10000자리 디스플레이
 304:	15 30       	cpi	r17, 0x05	; 5
 306:	39 f4       	brne	.+14     	; 0x316 <Display_Number_LCD+0x26>
 308:	80 91 48 01 	lds	r24, 0x0148
 30c:	0e 94 50 01 	call	0x2a0	; 0x2a0 <NumToAsc>
 310:	0e 94 34 03 	call	0x668	; 0x668 <LcdPutchar>
 314:	02 c0       	rjmp	.+4      	; 0x31a <Display_Number_LCD+0x2a>
	
	if( digit >= 4 )     LcdPutchar(NumToAsc(cnumber[3]));    // 1000자리 디스플레이 
 316:	14 30       	cpi	r17, 0x04	; 4
 318:	39 f4       	brne	.+14     	; 0x328 <Display_Number_LCD+0x38>
 31a:	80 91 47 01 	lds	r24, 0x0147
 31e:	0e 94 50 01 	call	0x2a0	; 0x2a0 <NumToAsc>
 322:	0e 94 34 03 	call	0x668	; 0x668 <LcdPutchar>
 326:	02 c0       	rjmp	.+4      	; 0x32c <Display_Number_LCD+0x3c>

	if( digit >= 3 )     LcdPutchar(NumToAsc(cnumber[2]));    // 100자리 디스플레이 
 328:	13 30       	cpi	r17, 0x03	; 3
 32a:	39 f4       	brne	.+14     	; 0x33a <Display_Number_LCD+0x4a>
 32c:	80 91 46 01 	lds	r24, 0x0146
 330:	0e 94 50 01 	call	0x2a0	; 0x2a0 <NumToAsc>
 334:	0e 94 34 03 	call	0x668	; 0x668 <LcdPutchar>
 338:	02 c0       	rjmp	.+4      	; 0x33e <Display_Number_LCD+0x4e>

	if( digit >= 2 )     LcdPutchar(NumToAsc(cnumber[1]));    // 10자리 디스플레이
 33a:	11 30       	cpi	r17, 0x01	; 1
 33c:	31 f0       	breq	.+12     	; 0x34a <Display_Number_LCD+0x5a>
 33e:	80 91 45 01 	lds	r24, 0x0145
 342:	0e 94 50 01 	call	0x2a0	; 0x2a0 <NumToAsc>
 346:	0e 94 34 03 	call	0x668	; 0x668 <LcdPutchar>

	if( digit >= 1 )     LcdPutchar(NumToAsc(cnumber[0]));    //  1자리 디스플레이
 34a:	80 91 44 01 	lds	r24, 0x0144
 34e:	0e 94 50 01 	call	0x2a0	; 0x2a0 <NumToAsc>
 352:	0e 94 34 03 	call	0x668	; 0x668 <LcdPutchar>

}
 356:	1f 91       	pop	r17
 358:	08 95       	ret

0000035a <__vector_16>:
    }
}


ISR(TIMER0_OVF_vect)   // Timer0 overflow interrupt( 10 msec)  service routine
{
 35a:	1f 92       	push	r1
 35c:	0f 92       	push	r0
 35e:	0f b6       	in	r0, 0x3f	; 63
 360:	0f 92       	push	r0
 362:	0b b6       	in	r0, 0x3b	; 59
 364:	0f 92       	push	r0
 366:	11 24       	eor	r1, r1
 368:	2f 93       	push	r18
 36a:	3f 93       	push	r19
 36c:	4f 93       	push	r20
 36e:	5f 93       	push	r21
 370:	6f 93       	push	r22
 372:	7f 93       	push	r23
 374:	8f 93       	push	r24
 376:	9f 93       	push	r25
 378:	af 93       	push	r26
 37a:	bf 93       	push	r27
 37c:	ef 93       	push	r30
 37e:	ff 93       	push	r31


    unsigned char i = 0 ;


    TCNT0 = 256 - 156;       //  내부클럭주기 = 1024/ (16x10^6) = 64 usec,  
 380:	84 e6       	ldi	r24, 0x64	; 100
 382:	82 bf       	out	0x32, r24	; 50
                             //  오버플로인터럽트 주기 = 10msec
                             //  156 = 10msec/ 64usec

    time_index++ ; 
 384:	80 91 55 01 	lds	r24, 0x0155
 388:	90 91 56 01 	lds	r25, 0x0156
 38c:	01 96       	adiw	r24, 0x01	; 1
 38e:	90 93 56 01 	sts	0x0156, r25
 392:	80 93 55 01 	sts	0x0155, r24


    if( time_index == 25 )    // 샘플링주기 =  250 msec = 10msec x 25 
 396:	89 31       	cpi	r24, 0x19	; 25
 398:	91 05       	cpc	r25, r1
 39a:	09 f0       	breq	.+2      	; 0x39e <__vector_16+0x44>
 39c:	ce c0       	rjmp	.+412    	; 0x53a <__vector_16+0x1e0>
    {

       time_index = 0; 
 39e:	10 92 56 01 	sts	0x0156, r1
 3a2:	10 92 55 01 	sts	0x0155, r1


      /**************   GAS Sensor signal detection(AD 변환) ************/

	   ADMUX &= ~0x1F;    //  ADC Chanel 0 : ADC0 선택
 3a6:	87 b1       	in	r24, 0x07	; 7
 3a8:	80 7e       	andi	r24, 0xE0	; 224
 3aa:	87 b9       	out	0x07, r24	; 7
	   ADMUX |= 0x01;
 3ac:	38 9a       	sbi	0x07, 0	; 7
	   

	   ADCSRA |= 0x40;   // ADC start 
 3ae:	36 9a       	sbi	0x06, 6	; 6

	   while( ( ADCSRA & 0x10 ) == 0x00  ) ;  // Check if ADC Conversion is completed 
 3b0:	34 9b       	sbis	0x06, 4	; 6
 3b2:	fe cf       	rjmp	.-4      	; 0x3b0 <__vector_16+0x56>
	    ADCSRA |= 0x10;  // 변환완료 비트 리셋
 3b4:	34 9a       	sbi	0x06, 4	; 6

	   GAS_sensor_ouput = ADC;   
 3b6:	84 b1       	in	r24, 0x04	; 4
 3b8:	95 b1       	in	r25, 0x05	; 5
 3ba:	90 93 3f 01 	sts	0x013F, r25
 3be:	80 93 3e 01 	sts	0x013E, r24
   //////////                                               /////////// 
   //////////  Avg_Num(4개) 개씩 이동 평균(Moving Average)  ///////////
   //////////                                               ///////////
   ////////////////////////////////////////////////////////////////////

	   if( count1 <= ( Avg_Num -1 ) )
 3c2:	80 91 53 01 	lds	r24, 0x0153
 3c6:	90 91 54 01 	lds	r25, 0x0154
 3ca:	20 91 51 01 	lds	r18, 0x0151
 3ce:	30 91 52 01 	lds	r19, 0x0152
 3d2:	84 30       	cpi	r24, 0x04	; 4
 3d4:	91 05       	cpc	r25, r1
 3d6:	b8 f4       	brcc	.+46     	; 0x406 <__vector_16+0xac>
	   {

             GAS_sensor_ouput_buf[ count1 ] = GAS_sensor_ouput ;
 3d8:	40 91 3e 01 	lds	r20, 0x013E
 3dc:	50 91 3f 01 	lds	r21, 0x013F
 3e0:	fc 01       	movw	r30, r24
 3e2:	ee 0f       	add	r30, r30
 3e4:	ff 1f       	adc	r31, r31
 3e6:	e7 5b       	subi	r30, 0xB7	; 183
 3e8:	fe 4f       	sbci	r31, 0xFE	; 254
 3ea:	51 83       	std	Z+1, r21	; 0x01
 3ec:	40 83       	st	Z, r20
			 GAS_Sum +=  GAS_sensor_ouput_buf[ count1 ] ; 
 3ee:	24 0f       	add	r18, r20
 3f0:	35 1f       	adc	r19, r21
 3f2:	30 93 52 01 	sts	0x0152, r19
 3f6:	20 93 51 01 	sts	0x0151, r18
          ////////////////////////////////////////////////////

           //  TMP_sensor_ouput_buf[ count1 ] = TMP_sensor_ouput ;
			// TMP_Sum +=  TMP_sensor_ouput_buf[ count1 ] ; 

	         count1++ ; 
 3fa:	01 96       	adiw	r24, 0x01	; 1
 3fc:	90 93 54 01 	sts	0x0154, r25
 400:	80 93 53 01 	sts	0x0153, r24
 404:	38 c0       	rjmp	.+112    	; 0x476 <__vector_16+0x11c>

	   } 
	   else
	   {

             GAS_Sum +=  GAS_sensor_ouput  ;	       // 가장 최근 값 더하고  
 406:	80 91 3e 01 	lds	r24, 0x013E
 40a:	90 91 3f 01 	lds	r25, 0x013F
 40e:	82 0f       	add	r24, r18
 410:	93 1f       	adc	r25, r19
             GAS_Sum -=  GAS_sensor_ouput_buf[ 0 ] ;   // 가장 오랜된 값 빼고 
 412:	20 91 49 01 	lds	r18, 0x0149
 416:	30 91 4a 01 	lds	r19, 0x014A
 41a:	82 1b       	sub	r24, r18
 41c:	93 0b       	sbc	r25, r19
 41e:	90 93 52 01 	sts	0x0152, r25
 422:	80 93 51 01 	sts	0x0151, r24

             GAS_sensor_ouput_avg = GAS_Sum / Avg_Num ;     // 4개 이동 평균 
 426:	96 95       	lsr	r25
 428:	87 95       	ror	r24
 42a:	96 95       	lsr	r25
 42c:	87 95       	ror	r24
 42e:	90 93 41 01 	sts	0x0141, r25
 432:	80 93 40 01 	sts	0x0140, r24

             for( i = 0; i <= (Avg_Num - 2) ; i++ )
			 {
                 GAS_sensor_ouput_buf[ i ]  = GAS_sensor_ouput_buf[ i+1 ] ;
 436:	80 91 4b 01 	lds	r24, 0x014B
 43a:	90 91 4c 01 	lds	r25, 0x014C
 43e:	90 93 4a 01 	sts	0x014A, r25
 442:	80 93 49 01 	sts	0x0149, r24
 446:	80 91 4d 01 	lds	r24, 0x014D
 44a:	90 91 4e 01 	lds	r25, 0x014E
 44e:	90 93 4c 01 	sts	0x014C, r25
 452:	80 93 4b 01 	sts	0x014B, r24
 456:	80 91 4f 01 	lds	r24, 0x014F
 45a:	90 91 50 01 	lds	r25, 0x0150
 45e:	90 93 4e 01 	sts	0x014E, r25
 462:	80 93 4d 01 	sts	0x014D, r24
			 } 

             GAS_sensor_ouput_buf[ Avg_Num - 1 ]  = GAS_sensor_ouput ;  
 466:	80 91 3e 01 	lds	r24, 0x013E
 46a:	90 91 3f 01 	lds	r25, 0x013F
 46e:	90 93 50 01 	sts	0x0150, r25
 472:	80 93 4f 01 	sts	0x014F, r24

}



	   if( GAS_sensor_ouput_avg <= 100 ) // 평상시 
 476:	80 91 40 01 	lds	r24, 0x0140
 47a:	90 91 41 01 	lds	r25, 0x0141
 47e:	85 36       	cpi	r24, 0x65	; 101
 480:	91 05       	cpc	r25, r1
 482:	60 f5       	brcc	.+88     	; 0x4dc <__vector_16+0x182>
	   {
	     LcdCommand(ALLCLR);
 484:	81 e0       	ldi	r24, 0x01	; 1
 486:	0e 94 f5 02 	call	0x5ea	; 0x5ea <LcdCommand>

		 LcdMove(0,0);
 48a:	80 e0       	ldi	r24, 0x00	; 0
 48c:	60 e0       	ldi	r22, 0x00	; 0
 48e:	0e 94 61 03 	call	0x6c2	; 0x6c2 <LcdMove>
		 LcdPuts("GAS Clean!!");
 492:	8b e1       	ldi	r24, 0x1B	; 27
 494:	91 e0       	ldi	r25, 0x01	; 1
 496:	0e 94 4d 03 	call	0x69a	; 0x69a <LcdPuts>

		 LcdMove(1,0);
 49a:	81 e0       	ldi	r24, 0x01	; 1
 49c:	60 e0       	ldi	r22, 0x00	; 0
 49e:	0e 94 61 03 	call	0x6c2	; 0x6c2 <LcdMove>
	   	 LcdPuts("GAS = ");
 4a2:	87 e2       	ldi	r24, 0x27	; 39
 4a4:	91 e0       	ldi	r25, 0x01	; 1
 4a6:	0e 94 4d 03 	call	0x69a	; 0x69a <LcdPuts>

		 LcdMove(1,6); 
 4aa:	81 e0       	ldi	r24, 0x01	; 1
 4ac:	66 e0       	ldi	r22, 0x06	; 6
 4ae:	0e 94 61 03 	call	0x6c2	; 0x6c2 <LcdMove>
         Display_Number_LCD( GAS_sensor_ouput_avg, 4 ); 
 4b2:	80 91 40 01 	lds	r24, 0x0140
 4b6:	90 91 41 01 	lds	r25, 0x0141
 4ba:	64 e0       	ldi	r22, 0x04	; 4
 4bc:	0e 94 78 01 	call	0x2f0	; 0x2f0 <Display_Number_LCD>

		 PORTB |= 0x10;   // PB4  : High ( LED OFF )
 4c0:	c4 9a       	sbi	0x18, 4	; 24
		 PORTB &= ~0x08;   // PB3  : Low ( LED ON )  
 4c2:	c3 98       	cbi	0x18, 3	; 24
		 PORTB |= 0x04;    // PB2  : High ( 부저 OFF ) 
 4c4:	c2 9a       	sbi	0x18, 2	; 24
		 DC_FAN_Run_Fwd( 0 );     // FAN 정회전 정지 
 4c6:	80 e0       	ldi	r24, 0x00	; 0
 4c8:	90 e0       	ldi	r25, 0x00	; 0
 4ca:	0e 94 67 00 	call	0xce	; 0xce <DC_FAN_Run_Fwd.1397>
		 Flag = 1;
 4ce:	81 e0       	ldi	r24, 0x01	; 1
 4d0:	90 e0       	ldi	r25, 0x00	; 0
 4d2:	90 93 7c 01 	sts	0x017C, r25
 4d6:	80 93 7b 01 	sts	0x017B, r24
 4da:	2f c0       	rjmp	.+94     	; 0x53a <__vector_16+0x1e0>
		
   

       }

	   else if( GAS_sensor_ouput_avg > 100 ) // 가스 감지시
 4dc:	80 91 40 01 	lds	r24, 0x0140
 4e0:	90 91 41 01 	lds	r25, 0x0141
 4e4:	85 36       	cpi	r24, 0x65	; 101
 4e6:	91 05       	cpc	r25, r1
 4e8:	40 f1       	brcs	.+80     	; 0x53a <__vector_16+0x1e0>
	   {	
 		  LcdCommand(ALLCLR);
 4ea:	81 e0       	ldi	r24, 0x01	; 1
 4ec:	0e 94 f5 02 	call	0x5ea	; 0x5ea <LcdCommand>

		  LcdMove(0,0);
 4f0:	80 e0       	ldi	r24, 0x00	; 0
 4f2:	60 e0       	ldi	r22, 0x00	; 0
 4f4:	0e 94 61 03 	call	0x6c2	; 0x6c2 <LcdMove>
	   	  LcdPuts("GAS Detecting!!");
 4f8:	8e e2       	ldi	r24, 0x2E	; 46
 4fa:	91 e0       	ldi	r25, 0x01	; 1
 4fc:	0e 94 4d 03 	call	0x69a	; 0x69a <LcdPuts>

		  LcdMove(1,0);
 500:	81 e0       	ldi	r24, 0x01	; 1
 502:	60 e0       	ldi	r22, 0x00	; 0
 504:	0e 94 61 03 	call	0x6c2	; 0x6c2 <LcdMove>
	   	  LcdPuts("GAS = ");
 508:	87 e2       	ldi	r24, 0x27	; 39
 50a:	91 e0       	ldi	r25, 0x01	; 1
 50c:	0e 94 4d 03 	call	0x69a	; 0x69a <LcdPuts>

		  LcdMove(1,6); 
 510:	81 e0       	ldi	r24, 0x01	; 1
 512:	66 e0       	ldi	r22, 0x06	; 6
 514:	0e 94 61 03 	call	0x6c2	; 0x6c2 <LcdMove>
          Display_Number_LCD( GAS_sensor_ouput, 4 ); 
 518:	80 91 3e 01 	lds	r24, 0x013E
 51c:	90 91 3f 01 	lds	r25, 0x013F
 520:	64 e0       	ldi	r22, 0x04	; 4
 522:	0e 94 78 01 	call	0x2f0	; 0x2f0 <Display_Number_LCD>
		
		  PORTB &= ~0x10;   // PB4  : Low ( LED ON )
 526:	c4 98       	cbi	0x18, 4	; 24
		  PORTB |= 0x08;   // PB3  : High ( LED OFF ) 
 528:	c3 9a       	sbi	0x18, 3	; 24
		  
		  DC_FAN_Run_Fwd( 50 );     // FAN 정회전 스피드 50
 52a:	82 e3       	ldi	r24, 0x32	; 50
 52c:	90 e0       	ldi	r25, 0x00	; 0
 52e:	0e 94 67 00 	call	0xce	; 0xce <DC_FAN_Run_Fwd.1397>
		  sound(); //부저 함수 호출
 532:	0e 94 bb 02 	call	0x576	; 0x576 <sound>
		  bluetooth(); //블루투스 함수 호출
 536:	0e 94 26 01 	call	0x24c	; 0x24c <bluetooth>
       }

   }


}
 53a:	ff 91       	pop	r31
 53c:	ef 91       	pop	r30
 53e:	bf 91       	pop	r27
 540:	af 91       	pop	r26
 542:	9f 91       	pop	r25
 544:	8f 91       	pop	r24
 546:	7f 91       	pop	r23
 548:	6f 91       	pop	r22
 54a:	5f 91       	pop	r21
 54c:	4f 91       	pop	r20
 54e:	3f 91       	pop	r19
 550:	2f 91       	pop	r18
 552:	0f 90       	pop	r0
 554:	0b be       	out	0x3b, r0	; 59
 556:	0f 90       	pop	r0
 558:	0f be       	out	0x3f, r0	; 63
 55a:	0f 90       	pop	r0
 55c:	1f 90       	pop	r1
 55e:	18 95       	reti

00000560 <msec_delay>:



void msec_delay(unsigned int n)
{	
	for(; n>0; n--)		// 1msec 시간 지연을 n회 반복
 560:	07 c0       	rjmp	.+14     	; 0x570 <msec_delay+0x10>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 562:	ef e9       	ldi	r30, 0x9F	; 159
 564:	ff e0       	ldi	r31, 0x0F	; 15
 566:	31 97       	sbiw	r30, 0x01	; 1
 568:	f1 f7       	brne	.-4      	; 0x566 <msec_delay+0x6>
 56a:	00 c0       	rjmp	.+0      	; 0x56c <msec_delay+0xc>
 56c:	00 00       	nop
 56e:	01 97       	sbiw	r24, 0x01	; 1
 570:	00 97       	sbiw	r24, 0x00	; 0
 572:	b9 f7       	brne	.-18     	; 0x562 <msec_delay+0x2>
		_delay_ms(1);		// 1msec 시간 지연
}
 574:	08 95       	ret

00000576 <sound>:
	}
}
void sound() // 부저 호출 함수
{

	PORTB &= ~0x04;    // PB2  : High ( 부저 ON )  
 576:	c2 98       	cbi	0x18, 2	; 24
	msec_delay(150);
 578:	86 e9       	ldi	r24, 0x96	; 150
 57a:	90 e0       	ldi	r25, 0x00	; 0
 57c:	0e 94 b0 02 	call	0x560	; 0x560 <msec_delay>
	PORTB |= 0x04;    // PB2  : High ( 부저 OFF )
 580:	c2 9a       	sbi	0x18, 2	; 24
	msec_delay(150); 
 582:	86 e9       	ldi	r24, 0x96	; 150
 584:	90 e0       	ldi	r25, 0x00	; 0
 586:	0e 94 b0 02 	call	0x560	; 0x560 <msec_delay>
	
}
 58a:	08 95       	ret

0000058c <usec_delay>:
		_delay_ms(1);		// 1msec 시간 지연
}

void usec_delay(unsigned int n)
{	
	for(; n>0; n--)		// 1usec 시간 지연을 n회 반복
 58c:	05 c0       	rjmp	.+10     	; 0x598 <usec_delay+0xc>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 58e:	25 e0       	ldi	r18, 0x05	; 5
 590:	2a 95       	dec	r18
 592:	f1 f7       	brne	.-4      	; 0x590 <usec_delay+0x4>
 594:	00 00       	nop
 596:	01 97       	sbiw	r24, 0x01	; 1
 598:	00 97       	sbiw	r24, 0x00	; 0
 59a:	c9 f7       	brne	.-14     	; 0x58e <usec_delay+0x2>
		_delay_us(1);		// 1usec 시간 지연
}
 59c:	08 95       	ret

0000059e <checkbusy>:
 59e:	85 e3       	ldi	r24, 0x35	; 53
 5a0:	8a 95       	dec	r24
 5a2:	f1 f7       	brne	.-4      	; 0x5a0 <checkbusy+0x2>
 5a4:	00 00       	nop
 5a6:	85 e3       	ldi	r24, 0x35	; 53
 5a8:	8a 95       	dec	r24
 5aa:	f1 f7       	brne	.-4      	; 0x5a8 <checkbusy+0xa>
 5ac:	00 00       	nop
 5ae:	85 e3       	ldi	r24, 0x35	; 53
 5b0:	8a 95       	dec	r24
 5b2:	f1 f7       	brne	.-4      	; 0x5b0 <checkbusy+0x12>
 5b4:	00 00       	nop
 5b6:	85 e3       	ldi	r24, 0x35	; 53
 5b8:	8a 95       	dec	r24
 5ba:	f1 f7       	brne	.-4      	; 0x5b8 <checkbusy+0x1a>
 5bc:	00 00       	nop
 5be:	85 e3       	ldi	r24, 0x35	; 53
 5c0:	8a 95       	dec	r24
 5c2:	f1 f7       	brne	.-4      	; 0x5c0 <checkbusy+0x22>
 5c4:	00 00       	nop
}
	static void checkbusy()
{
	_delay_us(10); _delay_us(10); _delay_us(10);
	_delay_us(10); _delay_us(10);
}
 5c6:	08 95       	ret

000005c8 <write_command>:

static void write_command(char command)

{
  char temp;
  temp = (command & 0xF0)|0x04;
 5c8:	98 2f       	mov	r25, r24
 5ca:	90 7f       	andi	r25, 0xF0	; 240
 5cc:	94 60       	ori	r25, 0x04	; 4

LCD_PORT = temp;
 5ce:	95 bb       	out	0x15, r25	; 21
LCD_PORT = temp & ~0x04;
 5d0:	9b 7f       	andi	r25, 0xFB	; 251
 5d2:	95 bb       	out	0x15, r25	; 21

temp = (command << 4) | 0x04;
 5d4:	82 95       	swap	r24
 5d6:	80 7f       	andi	r24, 0xF0	; 240
 5d8:	84 60       	ori	r24, 0x04	; 4

LCD_PORT = temp;
 5da:	85 bb       	out	0x15, r24	; 21
LCD_PORT = temp & ~0x04;
 5dc:	8b 7f       	andi	r24, 0xFB	; 251
 5de:	85 bb       	out	0x15, r24	; 21
 5e0:	85 e0       	ldi	r24, 0x05	; 5
 5e2:	8a 95       	dec	r24
 5e4:	f1 f7       	brne	.-4      	; 0x5e2 <write_command+0x1a>
 5e6:	00 00       	nop
_delay_us(1);
}
 5e8:	08 95       	ret

000005ea <LcdCommand>:
	LcdCommand(ENTMOD);

	LcdCommand(DISP_ON);
}
void LcdCommand(char command)
{
 5ea:	1f 93       	push	r17
 5ec:	18 2f       	mov	r17, r24
	checkbusy();
 5ee:	0e 94 cf 02 	call	0x59e	; 0x59e <checkbusy>
	write_command(command);
 5f2:	81 2f       	mov	r24, r17
 5f4:	0e 94 e4 02 	call	0x5c8	; 0x5c8 <write_command>
	if(command==ALLCLR || command==HOME)
 5f8:	11 50       	subi	r17, 0x01	; 1
 5fa:	12 30       	cpi	r17, 0x02	; 2
 5fc:	30 f4       	brcc	.+12     	; 0x60a <LcdCommand+0x20>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 5fe:	8f e3       	ldi	r24, 0x3F	; 63
 600:	9f e1       	ldi	r25, 0x1F	; 31
 602:	01 97       	sbiw	r24, 0x01	; 1
 604:	f1 f7       	brne	.-4      	; 0x602 <LcdCommand+0x18>
 606:	00 c0       	rjmp	.+0      	; 0x608 <LcdCommand+0x1e>
 608:	00 00       	nop
		_delay_ms(2);
}
 60a:	1f 91       	pop	r17
 60c:	08 95       	ret

0000060e <LcdInit>:
static void write_command(char command);
static void write_data(char ch);

void LcdInit(void)
{
	LCD_DDR = 0xff;
 60e:	8f ef       	ldi	r24, 0xFF	; 255
 610:	84 bb       	out	0x14, r24	; 20
 612:	8f e5       	ldi	r24, 0x5F	; 95
 614:	9a ee       	ldi	r25, 0xEA	; 234
 616:	01 97       	sbiw	r24, 0x01	; 1
 618:	f1 f7       	brne	.-4      	; 0x616 <LcdInit+0x8>
 61a:	00 c0       	rjmp	.+0      	; 0x61c <LcdInit+0xe>
 61c:	00 00       	nop
	_delay_ms(15);
	write_command(0x30);
 61e:	80 e3       	ldi	r24, 0x30	; 48
 620:	0e 94 e4 02 	call	0x5c8	; 0x5c8 <write_command>
 624:	8f e1       	ldi	r24, 0x1F	; 31
 626:	9e e4       	ldi	r25, 0x4E	; 78
 628:	01 97       	sbiw	r24, 0x01	; 1
 62a:	f1 f7       	brne	.-4      	; 0x628 <LcdInit+0x1a>
 62c:	00 c0       	rjmp	.+0      	; 0x62e <LcdInit+0x20>
 62e:	00 00       	nop
	_delay_ms(5);
	write_command(0x30);
 630:	80 e3       	ldi	r24, 0x30	; 48
 632:	0e 94 e4 02 	call	0x5c8	; 0x5c8 <write_command>
 636:	8f e9       	ldi	r24, 0x9F	; 159
 638:	9f e0       	ldi	r25, 0x0F	; 15
 63a:	01 97       	sbiw	r24, 0x01	; 1
 63c:	f1 f7       	brne	.-4      	; 0x63a <LcdInit+0x2c>
 63e:	00 c0       	rjmp	.+0      	; 0x640 <LcdInit+0x32>
 640:	00 00       	nop
	_delay_ms(1);
	write_command(0x32);
 642:	82 e3       	ldi	r24, 0x32	; 50
 644:	0e 94 e4 02 	call	0x5c8	; 0x5c8 <write_command>

	LcdCommand(FUNSET);
 648:	88 e2       	ldi	r24, 0x28	; 40
 64a:	0e 94 f5 02 	call	0x5ea	; 0x5ea <LcdCommand>
	LcdCommand(DISP_OFF);
 64e:	88 e0       	ldi	r24, 0x08	; 8
 650:	0e 94 f5 02 	call	0x5ea	; 0x5ea <LcdCommand>
	LcdCommand(ALLCLR);
 654:	81 e0       	ldi	r24, 0x01	; 1
 656:	0e 94 f5 02 	call	0x5ea	; 0x5ea <LcdCommand>
	LcdCommand(ENTMOD);
 65a:	86 e0       	ldi	r24, 0x06	; 6
 65c:	0e 94 f5 02 	call	0x5ea	; 0x5ea <LcdCommand>

	LcdCommand(DISP_ON);
 660:	8c e0       	ldi	r24, 0x0C	; 12
 662:	0e 94 f5 02 	call	0x5ea	; 0x5ea <LcdCommand>
}
 666:	08 95       	ret

00000668 <LcdPutchar>:
	if(command==ALLCLR || command==HOME)
		_delay_ms(2);
}

void LcdPutchar(char ch)
{
 668:	df 93       	push	r29
 66a:	cf 93       	push	r28
 66c:	0f 92       	push	r0
 66e:	cd b7       	in	r28, 0x3d	; 61
 670:	de b7       	in	r29, 0x3e	; 62
	checkbusy();
 672:	89 83       	std	Y+1, r24	; 0x01
 674:	0e 94 cf 02 	call	0x59e	; 0x59e <checkbusy>

static void write_data(char ch)
{
	unsigned char temp;

	temp = (ch & 0xF0) | 0x05;
 678:	89 81       	ldd	r24, Y+1	; 0x01
 67a:	98 2f       	mov	r25, r24
 67c:	90 7f       	andi	r25, 0xF0	; 240
 67e:	95 60       	ori	r25, 0x05	; 5

	LCD_PORT = temp;
 680:	95 bb       	out	0x15, r25	; 21
	LCD_PORT = temp & ~0x04;
 682:	9b 7f       	andi	r25, 0xFB	; 251
 684:	95 bb       	out	0x15, r25	; 21

	temp = (ch<<4) | 0x05;
 686:	82 95       	swap	r24
 688:	80 7f       	andi	r24, 0xF0	; 240
 68a:	85 60       	ori	r24, 0x05	; 5

	LCD_PORT = temp;
 68c:	85 bb       	out	0x15, r24	; 21
	LCD_PORT = temp & ~0x04;
 68e:	8b 7f       	andi	r24, 0xFB	; 251
 690:	85 bb       	out	0x15, r24	; 21

void LcdPutchar(char ch)
{
	checkbusy();
	write_data(ch);
}
 692:	0f 90       	pop	r0
 694:	cf 91       	pop	r28
 696:	df 91       	pop	r29
 698:	08 95       	ret

0000069a <LcdPuts>:

void LcdPuts(char* str)
{
 69a:	ef 92       	push	r14
 69c:	ff 92       	push	r15
 69e:	cf 93       	push	r28
 6a0:	df 93       	push	r29
 6a2:	e8 2e       	mov	r14, r24
 6a4:	e7 01       	movw	r28, r14
 6a6:	7e 01       	movw	r14, r28
 6a8:	f9 2e       	mov	r15, r25
 6aa:	e7 01       	movw	r28, r14
   while(*str)
 6ac:	02 c0       	rjmp	.+4      	; 0x6b2 <LcdPuts+0x18>
  {
   LcdPutchar(*str);
 6ae:	0e 94 34 03 	call	0x668	; 0x668 <LcdPutchar>
	write_data(ch);
}

void LcdPuts(char* str)
{
   while(*str)
 6b2:	89 91       	ld	r24, Y+
 6b4:	88 23       	and	r24, r24
 6b6:	d9 f7       	brne	.-10     	; 0x6ae <LcdPuts+0x14>
  {
   LcdPutchar(*str);
   str++;
  }
}
 6b8:	df 91       	pop	r29
 6ba:	cf 91       	pop	r28
 6bc:	ff 90       	pop	r15
 6be:	ef 90       	pop	r14
 6c0:	08 95       	ret

000006c2 <LcdMove>:

{ 

//  pos = (line << 6) + pos; 

	if(line == 0 )       pos = 0x00 + pos ;
 6c2:	88 23       	and	r24, r24
 6c4:	49 f0       	breq	.+18     	; 0x6d8 <LcdMove+0x16>
	else if( line == 1 ) pos = 0x40 + pos ;
 6c6:	81 30       	cpi	r24, 0x01	; 1
 6c8:	11 f4       	brne	.+4      	; 0x6ce <LcdMove+0xc>
 6ca:	60 5c       	subi	r22, 0xC0	; 192
 6cc:	05 c0       	rjmp	.+10     	; 0x6d8 <LcdMove+0x16>
	else if( line == 2 ) pos = 0x10 + pos ;
 6ce:	82 30       	cpi	r24, 0x02	; 2
 6d0:	11 f4       	brne	.+4      	; 0x6d6 <LcdMove+0x14>
 6d2:	60 5f       	subi	r22, 0xF0	; 240
 6d4:	01 c0       	rjmp	.+2      	; 0x6d8 <LcdMove+0x16>
	else                 pos = 0x50 + pos ;
 6d6:	60 5b       	subi	r22, 0xB0	; 176

  pos |= 0x80;
 
  LcdCommand(pos);
 6d8:	86 2f       	mov	r24, r22
 6da:	80 68       	ori	r24, 0x80	; 128
 6dc:	0e 94 f5 02 	call	0x5ea	; 0x5ea <LcdCommand>
}
 6e0:	08 95       	ret

000006e2 <LcdNewchar>:


void LcdNewchar(char ch, char font[])
{
 6e2:	ef 92       	push	r14
 6e4:	ff 92       	push	r15
 6e6:	0f 93       	push	r16
 6e8:	1f 93       	push	r17
 6ea:	df 93       	push	r29
 6ec:	cf 93       	push	r28
 6ee:	00 d0       	rcall	.+0      	; 0x6f0 <LcdNewchar+0xe>
 6f0:	cd b7       	in	r28, 0x3d	; 61
 6f2:	de b7       	in	r29, 0x3e	; 62
 int i;

 ch <<=3;
 6f4:	88 0f       	add	r24, r24
 6f6:	88 0f       	add	r24, r24
 6f8:	88 0f       	add	r24, r24
 ch|= 0x40;

 LcdCommand(ch);
 6fa:	80 64       	ori	r24, 0x40	; 64
 6fc:	69 83       	std	Y+1, r22	; 0x01
 6fe:	7a 83       	std	Y+2, r23	; 0x02
 700:	0e 94 f5 02 	call	0x5ea	; 0x5ea <LcdCommand>
 704:	69 81       	ldd	r22, Y+1	; 0x01
 706:	7a 81       	ldd	r23, Y+2	; 0x02
 708:	06 2f       	mov	r16, r22
 70a:	17 2f       	mov	r17, r23

 for(i=0;i<8;i++)
 70c:	ee 24       	eor	r14, r14
 70e:	ff 24       	eor	r15, r15
    LcdPutchar(font[i]);
 710:	f8 01       	movw	r30, r16
 712:	81 91       	ld	r24, Z+
 714:	8f 01       	movw	r16, r30
 716:	0e 94 34 03 	call	0x668	; 0x668 <LcdPutchar>
 ch <<=3;
 ch|= 0x40;

 LcdCommand(ch);

 for(i=0;i<8;i++)
 71a:	08 94       	sec
 71c:	e1 1c       	adc	r14, r1
 71e:	f1 1c       	adc	r15, r1
 720:	f8 e0       	ldi	r31, 0x08	; 8
 722:	ef 16       	cp	r14, r31
 724:	f1 04       	cpc	r15, r1
 726:	a1 f7       	brne	.-24     	; 0x710 <LcdNewchar+0x2e>
    LcdPutchar(font[i]);
}
 728:	0f 90       	pop	r0
 72a:	0f 90       	pop	r0
 72c:	cf 91       	pop	r28
 72e:	df 91       	pop	r29
 730:	1f 91       	pop	r17
 732:	0f 91       	pop	r16
 734:	ff 90       	pop	r15
 736:	ef 90       	pop	r14
 738:	08 95       	ret

0000073a <__udivmodhi4>:
 73a:	aa 1b       	sub	r26, r26
 73c:	bb 1b       	sub	r27, r27
 73e:	51 e1       	ldi	r21, 0x11	; 17
 740:	07 c0       	rjmp	.+14     	; 0x750 <__udivmodhi4_ep>

00000742 <__udivmodhi4_loop>:
 742:	aa 1f       	adc	r26, r26
 744:	bb 1f       	adc	r27, r27
 746:	a6 17       	cp	r26, r22
 748:	b7 07       	cpc	r27, r23
 74a:	10 f0       	brcs	.+4      	; 0x750 <__udivmodhi4_ep>
 74c:	a6 1b       	sub	r26, r22
 74e:	b7 0b       	sbc	r27, r23

00000750 <__udivmodhi4_ep>:
 750:	88 1f       	adc	r24, r24
 752:	99 1f       	adc	r25, r25
 754:	5a 95       	dec	r21
 756:	a9 f7       	brne	.-22     	; 0x742 <__udivmodhi4_loop>
 758:	80 95       	com	r24
 75a:	90 95       	com	r25
 75c:	bc 01       	movw	r22, r24
 75e:	cd 01       	movw	r24, r26
 760:	08 95       	ret

00000762 <_exit>:
 762:	f8 94       	cli

00000764 <__stop_program>:
 764:	ff cf       	rjmp	.-2      	; 0x764 <__stop_program>
